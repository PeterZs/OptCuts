% !TeX root = OptCuts.tex

%\section{Joint Discrete-Continuous Search}
\section{Search Procedure}%Jointly Discrete and Continuous Search}%<--- sounds weird
\label{sec:DCSearch}

Our primal update is a search procedure towards minimizing \eqref{eq:L} for a temporarily-fixed $\lambda$. 
% we will address details of how we update $\lambda$ below in Section\ \ref{}. 
Rather than trying to solve a potentially ill-conditioned real-valued optimization by approximating $T$ with $U$\ \cite{Poranne2017Autocuts}, we alternate local optimizations over $U$ and then $T$. %We augment a smooth descent search with a search over discrete topology. See Section~\ref{sec:DCSearch} for more details.%<--- these two sentences don't make sense, this is the topic of the current section

Our smooth descent steps apply standard continuous search. We locally minimize distortion $E_d$ over vertices $U$ while holding topology, $T$, fixed. Here we apply Newton-type method detailed in Section~\ref{sec:descentStep}.
%
Our topology descent step then applies a discrete search over local topology changes. We search neighboring topology to maximize a first-order reduction in the Lagrangian $L$ detailed in Section~\ref{sec:topologyStep}. 

In total, by ensuring monotonic decrease in $L$ over both the smooth and topology descent steps, we then prove that a near-stationary point can be reached for any input within a bounded number of alternations (Section~\ref{sec:convergence}). \danny{for varying $\lambda$ - i.e. our constrained problem seems like we need to spend a bit more work on this - see comments below.} 

\subsection{Motivation}

Our search procedure is essentially a graph search. However, due to the potentially huge computational cost, it is not possible to directly apply common graph search methods.

The UV topology space we are searching in can be represented using a directed graph $\mathcal{G}_T$ with its vertices $v_T \in \mathcal{V}_T$ being all possible UV topologies of a given 3D surface, and its edges $e_T \in \mathcal{E}_T$ are the local topological operations conducted on the UV map that can transform one UV topology to a nearby topology. Currently we support boundary and interior vertex splits, as well as corner vertex merge operations. \justin{add a small figure with these} 

We define the value $f_v$ of vertex $v^i_T$ as 
\[ f_v(v^i_T) = \min_{U} L(T^i, U) = E_s(T^i) + \min_{U} E_d(T^i, U) \]
and the weights $f_e$ of edge $e^{i,j}_{T}$ from $v^i_T$ to $v^j_T$ as 
\[ f_e(e^{i,j}_T) = f_v(v^j_T) - f_v(v^i_T). \]
Thus our problem could be restated as starting from an initial UV topology $v^0_T$ on the topology graph $\mathcal{G}_T$, search for a $v^i_T$ where $f_e(e^{i,j}_T) \geq 0$ is true for all $e^{i,j}_T \in \mathcal{E}^i_T$ ($\mathcal{E}^i_T$ is the set of all local topological operations in our dictionary that could be conducted on $v^i_T$).

Computing $f_v$ for one UV topology, however, requires a proper setting of initial UV coordinates plus a whole process of real-valued optimization. Moreover, even the number of neighbors of one UV topology is in the scale of $n_p$. These in practice prevent us from treating our problem as a usual graph search problem. Consequently, we construct a single search path on $\mathcal{G}_T$ and only approximate $f_v$ and $f_e$ in a topological first-order manner to guide the search along the path, where intermediate UV maps are also served as the initial points of the next search step.

\subsection{Primal Update}

In iteration $k$, given UV map $(T^{k-1}, U^{k-1})$ of the input surface mesh $M$, we conduct a joint discrete-continuous search to update both $T$ and $U$ towards minimizing $L$ (See Algorithm~\ref{alg:DCSearch}).

Similar to continuous search in smooth descent steps (Algorithm~\ref{alg:descentStep}), topology search is also composed of two stages: First decide a search direction (initiating a seam edit), and then compute a proper step size (extending the edit) to ensure sufficient energy decrease. There is no point in searching for every neighboring UV topology since, for example, initiating a cut in near-isometric regions will not help improve the map much. Thus we have a filtered candidate operation set $\hat{\mathcal{E}}^i_T$ for each topology descent step $i$ (Section~\ref{sec:topologyStep}). When deciding a direction, we fill the set with all promising operations produced by operation filtering (Section~\ref{sec:operationFiltering}), while when computing the step size, we fill then set with only the same operation as in the previous topology descent step for extending the step size.

\begin{algorithm}[h]
\SetAlgoLined
\KwData{$M$, $T^{k-1}$, $U^{k-1}$}
\KwResult{$T^k$, $U^k$}
$i \leftarrow 1$, $T^{k,1} \leftarrow T^{k-1}$, $U^{k,1} \leftarrow U^{k-1}$\;
$\hat{\mathcal{E}}^{k,1}_T \leftarrow$ operationFiltering(), $\delta^{k,1} = 0$\;
\Do{smooth descent step not converged}
{
	($T^{k,i+1}$, $U_a^{k,i}$) $\leftarrow$ topologyDescentStep($M$, $T^{k,i}$, $U^{k,i}$, $\hat{\mathcal{E}}^{k,i}_T$, $\delta^{k,i}$)\;
	($U^{k,i+1}$, $\delta^{k,i+1}$) $\leftarrow$ smoothDescentStep($M$, $T^{k,i+1}$, $U_a^{k,i}$)\;
	$\hat{\mathcal{E}}^{k,i+1}_T \leftarrow$ operations for extension\;
	$i \leftarrow i+1$\;
}
$T^k \leftarrow T^{k,i}$, $U^k \leftarrow U^{k,i}$
\caption{Primal Update $k$}
\label{alg:DCSearch}
\end{algorithm}

\subsection{Energy Definition}

To start with, we use symmetric Dirichlet energy~\cite{Smith2015Bijective} as our distortion energy, normalized by surface area:
\[ E_d = E_{SD} = \frac{1}{\sum_{t\in\mathcal{F}} |A_t|} \sum_{t\in\mathcal{F}} |A_t|(\sigma_{t,1}^2 + \sigma_{t,2}^2 + \sigma_{t,1}^{-2} + \sigma_{t,2}^{-2}) \]
where $\mathcal{F}$ is the set of all triangles, $|A_t|$ is the area of triangle $t$ on the input surface, and $\sigma_{t,i}$ is the $i$-th singular value of the deformation gradient of triangle $t$.

For seam energy, we simply use a normalized seam length:
\[ E_s = E_{SL} = \frac{1}{\sqrt{(\sum_{t\in\mathcal{F}} |A_t|)/\pi}} \sum_{i \in \mathcal{S}} |e_i| \]
where $\mathcal{S}$ is the set of all seam edges on the input surface, $|e_i|$ is the original length of edge $i$.

With the energies normalized, our $L$ is invariant of coordinate scale and resolution for meshes with the same shape.

\minchen{[TODO] fix iteration super script in Section~\ref{sec:descentStep} and \ref{sec:topologyStep}}

\input{descentSteps}

\input{topologySteps}

\subsection{Operation Filtering}
\label{sec:operationFiltering}
As the number of vertex that could be splitted is in the scale of $n_p$, and initiating a cut in near-isometric regions will not help improve the UV map much, we filter the vertices to be considered in a split operation by computing the standard deviation of the local individual energy gradients on a vertex and only considering the top $n_p^{0.6}$ vertices with large deviation. \minchen{[TODO] why not filtering by energy? how to filter it well for bijective parameterization?}\justin{will this heuristic mess up the convergence theory?}

\subsection{Convergence}
\label{sec:convergence}

As our method is defined to guarantee convergence to a local optimum, we now analyze the convergence rate. First, $L$ monotonically decreases in each step. Now we look at smooth descent step $i$ and $i+1$, from $L^i \geq L^{i+1}$ we have
\[ E^i_{SD} - E^{i+1}_{SD} \geq \frac{1}{\lambda} (E^{i+1}_{se} - E^i_{se}) \geq \frac{1}{\lambda\sqrt{(\sum_t |A_t|)/\pi}} |e|_{min} \]
if we now only consider splitting operations that keep increasing $E_{se}$. $E_{SD}$ is lower-bounded theoretically by $4$, so we have
\[ n_{alter} \leq \frac{\lambda\sqrt{(\sum_t |A_t|)/\pi}}{|e|_{min}} (E^0_{SD} - 4) \]
The most important hint we can read from this is, to accelerate convergence, we can move through multiple vertices on $G_T$ in each topology descent step to increase $E^{i+1}_{se} - E^i_{se}$.

\minchen{[NOTE] seems not intuitive to generalize to involve merge operations}
\justin{nothing about this discussion seems to involve convergence rate.} \minchen{maybe change "rate" to "speed"?}