% !TeX root = OptCuts.tex

\section{Results and Discussion}
\label{sec:results}

\subsection{Comparisons}

Since our method can generate UV maps with locally optimal seams under a certain distortion bound, we are able to directly use the output $E_s$ of different methods at the same distortion level as the evaluation metric. This metric is consistent among comparisons with all methods. Moreover, it also fits in well to practical scenarios where the control of distortions are more intuitive to the users and as-short-as-possible seams is expected.

We demonstrate the capabilities of our framework by comparing to AutoCuts~\cite{Poranne2017Autocuts}, Geometry Images~\cite{Gu2002Geometry}, and Seamster~\cite{Sheffer2002Seamster}.

\minchen{[TODO] provide detailed settings on the compared methods, and how much user assistance was needed for other methods}

\paragraph{AutoCuts}
We first run AutoCuts, and set their output distortions as the upper bounds in our method for each input surface.

\paragraph{Geometry Images}
Given the same input surface and initial UV maps, we reach identical distortion bounds with shorter seam lengths (Figure~\ref{fig:comp_GI}).
When we change the settings progressively to obtain nearly isometric UV maps, the quality of the seams by Geometry Images drop drastically while our method keeps generating high-quality seams (Figure~\ref{fig:comp_GI_strictBounds}).
Using seams output by Geometry Images to construct our initial UV map, we achieve the same distortion bound with bijectivity constraints and shorter seams (Figure~\ref{fig:comp_GI_outputAsInit}).

\paragraph{Seamster}

\minchen{[TODO] add specific analysis to the comparison between ours and the 3 methods}

They key difference between our framework and two-pass methods is that, our seams are computed to directly improve the given distortion measure rather than some approximated heuristics. Besides, since the problem is highly nonlinear, seams that benefits one region might be redundant due to the existance of another seam in a near or far region. Our framework is capable of removing those redundancy with our topology search, but the two-pass methods can not.


\subsection{Experiments}
\label{sec:results_exp}

\paragraph{Initial Embedding}
To show that we search for locally optimal UV maps regardless of the given initial embedding, we run our method starting from our standard initializations, triangle soups, and preliminary UV maps produced by other methods or by the users. All the output UV maps are with high quality (Figure~\ref{fig:bad_init_still_ends_well}) \minchen{[TODO]}.

\paragraph{Triangulation Invariance} \minchen{[TODO] not sure whether applicable}

\paragraph{Scalability} \minchen{[TODO]}

\subsection{Variations}
\label{sec:results_variations}

Without changing the framework, simply reformulating $L = E_s + \lambda E_d$ according to different needs enables OptCuts to solve mesh parameterization problems in many variations:

\paragraph{Global Bijectivity} \danny{suggest we no longer consider this a variation and instead use it as a key part of our full algorithm - see my comments earlier.} \minchen{[DOING]} Augmenting our $E_d$ with a collision handling energy $E_b$ will easily achieve joint seam placement and bijective mesh parameterization. We show that by adding a scaffold mesh~\cite{Jiang2017Simplicial} to the voided regions of the UV map and preventing the scaffold mesh from degenerate, our method automatically generate high-quality bijective maps with optimal seams different from that of locally injective parameterization (Figure~\ref{fig:bijective_vs_injective}). When computing $\hat{f}_e$, besides also including the one-ring triangles on the scaffold mesh for computing energy decrease, we also need to move the splitted vertices slightly apart to leave room for inserting new scaffold mesh triangles.

\paragraph{Conformal Parameterization} \minchen{[TODO]} Using a conformal energy~\cite{Hormann2000MIPS,Sheffer2005ABFPP} for $E_d$ will achieve joint seam placement and conformal parameterization. Figure~\ref{fig:conformal_vs_isometry} shows some results with $E_d = E_{ABForMIPS}$~\cite{} compared to results with $E_d = E_{SD}$, where different seams are generated while our framework stays the same.

\paragraph{Regional Seam Placement} \minchen{[TODO]} On the discrete side, if we reweight $E_{SL}$ with an edge prior provided by the user or an algorithm~\cite{} as
\[ E_s = \hat{E}_{SL} = \sum_{i\in\mathcal{S}} w_{SL,i} E_{SL,i} \quad w_{SL,i} \in \mathcal{R^+} \]
we could bias the seam placement towards regions e.g. where continuity is less in demand (Figure~\ref{fig:regional_seam_placement}).

\minchen{[TODO] add specific analysis to the results}

The key is that with all these variations, our framework stays the same, and it efficiently generates optimal seams for the specific problem formulation.